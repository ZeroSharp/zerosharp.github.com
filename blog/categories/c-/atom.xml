<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c# | ZeroSharp]]></title>
  <link href="http://ZeroSharp.github.com/blog/categories/c-/atom.xml" rel="self"/>
  <link href="http://ZeroSharp.github.com/"/>
  <updated>2015-06-09T12:44:02+01:00</updated>
  <id>http://ZeroSharp.github.com/</id>
  <author>
    <name><![CDATA[Robert Anderson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fixing slow debugging of ASP.NET applications]]></title>
    <link href="http://ZeroSharp.github.com/fixing-slow-debugging-of-asp-dot-net-applications/"/>
    <updated>2015-06-03T21:31:00+01:00</updated>
    <id>http://ZeroSharp.github.com/fixing-slow-debugging-of-asp-dot-net-applications</id>
    <content type="html"><![CDATA[<p>For a while I've noticed an annoying slowness when debugging ASP.NET applications from Visual Studio. Just after every page load it takes about a second before the buttons become clickable. I noticed mostly when debugging XAF applications, perhaps because the pages are quite complex.</p>

<p>Turns out the culprit is something called <a href="http://www.asp.net/visual-studio/overview/2013/using-browser-link">Browser Link</a> which was introduced in Visual Studio 2013. It's enabled by default.</p>

<p>To turn it off you can turn it off from the menu:</p>

<p><img src="/images/blog/browserlink-001.png"></p>

<p>Or you can add the following to your web.config file.
<code>xml
&lt;appSettings&gt;
  &lt;add key="vs:EnableBrowserLink" value="false"/&gt;
&lt;/appSettings&gt;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DevExpress 14.2 review]]></title>
    <link href="http://ZeroSharp.github.com/devexpress-14-dot-2-review/"/>
    <updated>2015-01-20T08:35:00+00:00</updated>
    <id>http://ZeroSharp.github.com/devexpress-14-dot-2-review</id>
    <content type="html"><![CDATA[<p><span class='pullquote-right' data-pullquote='The truly outstanding new feature is the ASP.NET report writer'>
This post is an overview of the brand new version XAF 14.2. The truly outstanding new feature is the ASP.NET report writer which is now available in all XAF applications.</p>

<p>A few months ago, we lost a potential sale because the customer wanted the ability to create custom reports from within the browser. We told them it was impossible to provide a fully-fledged report designer within our web application - but the DevExpress guys have done it! And how! </span></p>

<h2>The web-based report designer</h2>

<p>Let's fire up the MainDemo application and navigate to the reports view. The first thing to notice is that there is a new action <em>Show Report Designer</em>.</p>

<p><img src="/images/blog/devexpress-14-2-review-001.png"></p>

<p>The designer action is disabled because the selected report is <em>predefined</em>. Predefined reports are a feature of Reports v2 which were introduced in version 13.2 (<a href="/devexpress-13-dot-2-review-part-1">see my previous review</a>). So first, we clone the existing predefined report. I renamed the copy (via the edit button) so that we can tell them apart.</p>

<p><img src="/images/blog/devexpress-14-2-review-002.png"></p>

<p>Now the <em>Show Report Designer</em> action is enabled. Let's click it. <em>Whoa! That's one impressive user interface for a web application!</em></p>

<p><img src="/images/blog/devexpress-14-2-review-003.png"></p>

<p>Let's add a chart and a few controls. I thought (incorrectly) that the link to the domain model might be somewhat lacking because the report designer is not designed specifically for XAF (you can also use it with non-XAF ASP.NET or ASP.NET MVC applications) but navigating the available domain objects to select a property seemed very natural and simple.</p>

<p><img src="/images/blog/devexpress-14-2-review-005.png"></p>

<p>I had a few little mouse issues while trying to resize or move controls, and there were a couple of places where the interface seemed slightly sluggish, but these were very minor issues. In general the designer is slick and easy to use. I also had a little difficulty finding the <em>Save</em> button, but here it is:</p>

<p><img src="/images/blog/devexpress-14-2-review-007.png"></p>

<p>And here's the live output after my modifications.</p>

<p><img src="/images/blog/devexpress-14-2-review-006.png"></p>

<p>You can also start from scratch with a new blank report.</p>

<p><img src="/images/blog/devexpress-14-2-review-004.png"></p>

<p>This report designer is an <strong>extremely impressive achievement</strong>. I played around with it for over an hour and it did not crash once. I managed to implement everything I tried including a chart, a bar code and a new data field.</p>

<p>There are some features missing from the web-based report designer compared to the Windows Forms version. Most significant is the ability to attach events and scripts to controls. Here is a <a href="https://documentation.devexpress.com/#XtraReports/CustomDocument14651">full feature comparison table</a>.</p>

<p>I had a quick look for the tools they used to implement it. It looks like it uses <a href="https://jquery.com">jQuery</a>, <a href="https://jqueryui.com">jQuery.UI</a> and <a href="https://knockoutjs.com">knockout.js</a> and you can automatically bundle the required libraries via a new setting in the web.config. There is <a href="https://documentation.devexpress.com/#XtraReports/CustomDocument17558">some more information here</a>.</p>

<p>On the whole I am utterly impressed. Hats off to the DevExpress team!</p>

<h2>Other new features in XAF 14.2</h2>

<p>The new 14.2 includes several other new features. These include the ability to store user settings in the data store as well as improvements to the speed of the grids. For a full list of the new features and improvements see <a href="https://community.devexpress.com/blogs/eaf/archive/2014/11/18/xaf-brand-new-module-amp-features-for-both-windows-and-the-web-coming-soon-in-v14-2.aspx">here</a> and <a href="https://community.devexpress.com/blogs/eaf/archive/2014/11/20/xaf-enhancements-to-existing-features-amp-performance-tuning-coming-soon-in-v14-2.aspx">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ELMAH with DevExpress XAF]]></title>
    <link href="http://ZeroSharp.github.com/elmah-with-devexpress-xaf/"/>
    <updated>2014-10-08T15:45:00+01:00</updated>
    <id>http://ZeroSharp.github.com/elmah-with-devexpress-xaf</id>
    <content type="html"><![CDATA[<p><a href="https://code.google.com/p/elmah/">ELMAH (Error Logging Modules and Handlers)</a> is an open source library for logging unhandled exceptions. This post explains how to get it running with the <a href="https://www.devexpress.com/Products/NET/Application_Framework/">DevExpress XAF</a> main demo.</p>

<p>A couple of amazing facts about ELMAH.</p>

<ul>
<li>It has been around since 2004!</li>
<li>It was written by <a href="http://www.raboof.com/">Atif Aziz</a> who happens to be an old school-friend from the International School of Geneva.</li>
</ul>


<p>XAF provides <a href="https://documentation.devexpress.com/#xaf/CustomDocument2704">quite extensive error handling options</a> out of the box, but I have found Elmah better suited to production environments because of the ability to remotely view the full error log.</p>

<h2>Setting up</h2>

<p>First, get the ELMAH package via NuGet into the MainDemo.Web project. ELMAH provides dozens of different methods of persisting the error log. For this example we'll choose one of the simplest. Make sure you select the <em>ELMAH on XML Log</em> package.</p>

<p><img src="/images/blog/xaf-with-elmah-001.png"></p>

<p>NuGet makes several automatic modifications to the <em>web.config</em>. Unfortunately, these are not quite accurate enough for XAF. The changes you need to make are detailed below:</p>

<p>Add a <code>&lt;configSection&gt;</code> for ELMAH as alongside the existing devExpress one.</p>

<p>```xml web.config
  <configSections></p>

<pre><code>&lt;sectionGroup name="devExpress"&gt;...&lt;/sectionGroup&gt; &lt;!-- this should already exist--&gt;
&lt;sectionGroup name="elmah"&gt; &lt;!-- this is new--&gt;
  &lt;section name="security" requirePermission="false" type="Elmah.SecuritySectionHandler, Elmah" /&gt;
  &lt;section name="errorLog" requirePermission="false" type="Elmah.ErrorLogSectionHandler, Elmah" /&gt;
  &lt;section name="errorMail" requirePermission="false" type="Elmah.ErrorMailSectionHandler, Elmah" /&gt;
  &lt;section name="errorFilter" requirePermission="false" type="Elmah.ErrorFilterSectionHandler, Elmah" /&gt;
 &lt;/sectionGroup&gt;
</code></pre>

<p>  </configSections>
```</p>

<p>Your <code>&lt;system.webServer&gt;</code> section should look like this:</p>

<p>```xml web.config
  &lt;system.webServer></p>

<pre><code>&lt;handlers&gt;...&lt;/handlers&gt; &lt;!-- This is unchanged --&gt;
&lt;validation validateIntegratedModeConfiguration="false" /&gt;
&lt;modules&gt;
  &lt;add name="ASPxHttpHandlerModule" type="DevExpress.Web.ASPxClasses.ASPxHttpHandlerModule, DevExpress.Web.v14.1, Version=14.1.7.0, Culture=neutral, PublicKeyToken=b88d1754d700e49a" /&gt;
  &lt;add name="ErrorLog" type="Elmah.ErrorLogModule, Elmah" preCondition="managedHandler" /&gt;
  &lt;add name="ErrorMail" type="Elmah.ErrorMailModule, Elmah" preCondition="managedHandler" /&gt;
  &lt;add name="ErrorFilter" type="Elmah.ErrorFilterModule, Elmah" preCondition="managedHandler" /&gt;
&lt;/modules&gt;
</code></pre>

<p>  &lt;/system.webServer>
```</p>

<p>Add a <code>&lt;location&gt;</code> for the path <em>elmah.axd</em> (alongside the existing <code>&lt;location&gt;</code> tags).</p>

<p>```xml web.config
  <location path="elmah.axd" inheritInChildApplications="false"></p>

<pre><code>&lt;system.web&gt;
  &lt;httpHandlers&gt;
    &lt;add verb="POST,GET,HEAD" path="elmah.axd" type="Elmah.ErrorLogPageFactory, Elmah" /&gt;
  &lt;/httpHandlers&gt;
  &lt;!-- 
    See http://code.google.com/p/elmah/wiki/SecuringErrorLogPages for 
    more information on using ASP.NET authorization securing ELMAH.

  &lt;authorization&gt;
    &lt;allow roles="admin" /&gt;
    &lt;deny users="*" /&gt;  
  &lt;/authorization&gt;
  --&gt;  
&lt;/system.web&gt;
&lt;system.webServer&gt;
  &lt;handlers&gt;
    &lt;add name="ELMAH" verb="POST,GET,HEAD" path="elmah.axd" type="Elmah.ErrorLogPageFactory, Elmah" preCondition="integratedMode" /&gt;
  &lt;/handlers&gt;
&lt;/system.webServer&gt;
</code></pre>

<p>  </location>
```</p>

<p>Add a new <code>&lt;elmah&gt;</code> section. I put mine just before the final <code>&lt;/configuration&gt;</code> tag.</p>

<p>```xml web.config
  <elmah></p>

<pre><code>&lt;errorLog type="Elmah.XmlFileErrorLog, Elmah" logPath="~/App_Data/Elmah.Errors" /&gt;
&lt;!--
    See http://code.google.com/p/elmah/wiki/SecuringErrorLogPages for 
    more information on remote access and securing ELMAH.
--&gt;
&lt;security allowRemoteAccess="false" /&gt;
</code></pre>

<p>  </elmah>
```</p>

<p>Now modify <em>HttpModules.Web.Config</em> to look like this:</p>

<p><code>xml HttpModules.Web.Config
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;httpModules&gt;
  &lt;add name="ASPxHttpHandlerModule" type="DevExpress.Web.ASPxClasses.ASPxHttpHandlerModule, DevExpress.Web.v14.1, Version=14.1.7.0, Culture=neutral, PublicKeyToken=b88d1754d700e49a" /&gt;
  &lt;add name="ErrorLog" type="Elmah.ErrorLogModule, Elmah" /&gt;
  &lt;add name="ErrorMail" type="Elmah.ErrorMailModule, Elmah" /&gt;
  &lt;add name="ErrorFilter" type="Elmah.ErrorFilterModule, Elmah" /&gt;
&lt;/httpModules&gt;
</code></p>

<p>Now we need to extend XAF's standard error handling. Create a new class in the web application.</p>

<p>```c#
public class ElmahErrorHandling : ErrorHandling
{</p>

<pre><code>protected override void LogException(ErrorInfo errorInfo)
{
    base.LogException(errorInfo);

    if (errorInfo.Exception != null)
        Elmah.ErrorSignal.FromCurrentContext().Raise(errorInfo.Exception);
}
</code></pre>

<p>}
```</p>

<p>And then modify <em>Global.asax.cs</em> to instantiate the new class</p>

<p>```c#</p>

<pre><code>    protected void Application_Start(object sender, EventArgs e) {
        ErrorHandling.Instance = new ElmahErrorHandling(); // &lt;---this line is new
        ASPxWebControl.CallbackError += new EventHandler(Application_Error);
</code></pre>

<h1>if DEBUG</h1>

<pre><code>        TestScriptsManager.EasyTestEnabled = true;
</code></pre>

<h1>endif</h1>

<pre><code>    }
</code></pre>

<p>```</p>

<p>The complete files are available with the <a href="https://github.com/ZeroSharp/Xaf_MainDemo_Elmah">source code</a>.</p>

<p>Now run the application and trigger an unhandled exception. Change the URL to something that does not exist. Or open any detail view and modify the URL so that the Guid in the <em>ShortcutObjectKey</em> is invalid (replace a digit with an 'X'). Then the application error page appears.</p>

<p><img src="/images/blog/xaf-with-elmah-002.png"></p>

<p>Then return to the application and change the URL to <code>Elmah.axd</code>. You are looking at the log of all unhandled exceptions.</p>

<p><img src="/images/blog/xaf-with-elmah-003.png"></p>

<p>And for each exception, you can view the full details of any logged exception including coloured stack trace and full server variables.</p>

<p><img src="/images/blog/xaf-with-elmah-004.png"></p>

<h2>ELMAH options</h2>

<p>By default, ELMAH is configured to disallow remote access to the error logs -  only a local user can get to <em>elmah.axd</em>. If you take care of the security implications it can be very useful to enable remote access and  monitor the logs on your production servers.</p>

<p>We chose to use an XML file for each error but ELMAH is entirely pluggable. There are dozens of alternatives for persisting the error log including Sql Server, an RSS feeds, to Twitter, even to <a href="http://code.google.com/p/elmah/wiki/ProwlingErrors">an iPhone app</a>. There are even third party sites such as <a href="http://elmah.io">elmah.io</a> who will host your error logs for you.</p>

<p>One of the advantages of using XML files is that the files can be copied to another machine. If you look in <em>MainDemo.Web\App_Data\Elmah.Errors</em>, you will find the resulting xml files.</p>

<p><img src="/images/blog/xaf-with-elmah-005.png"></p>

<p>You can just copy these files to another installation's <em>Elmah.Errors</em> folder and the log will show up when you visit <em>Elmah.axd</em>.</p>

<p>One final note. ELMAH was developed for ASP.NET applications and web services, but it is possible to get it to work with other types of applications such as Windows Forms, Windows Service or console applications. Check out <a href="https://stackoverflow.com/questions/841451/using-elmah-in-a-console-application">this StackOverflow question</a>.</p>

<p>The source code for this example is <a href="https://github.com/ZeroSharp/Xaf_MainDemo_Elmah">on GitHub</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Replacing a class at runtime using Ninject and Roslyn - Part 4: Roslyn]]></title>
    <link href="http://ZeroSharp.github.com/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-4/"/>
    <updated>2014-09-17T08:08:00+01:00</updated>
    <id>http://ZeroSharp.github.com/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-4</id>
    <content type="html"><![CDATA[<p>This is the fourth and final part of a series about using Roslyn with dependency injection to create a flexible and powerful plug-in framework. Here I review the parts of the solution that deal with the Roslyn runtime compilation of plug-ins. Check out <a href="https://github.com/ZeroSharp/RoslynPlugins">the working example on GitHub</a>.</p>

<p>Previously</p>

<ul>
<li><a href="/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-1/">Part 1: The Goal</a></li>
<li><a href="/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-2/">Part 2: The Solution</a></li>
<li><a href="/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-3/">Part 3: Dependency Injection</a></li>
</ul>


<h2>Roslyn</h2>

<p>Let's look at some of the main classes used to compile plug-in code at runtime.</p>

<p>The <code>PluginSnippetCompiler.Compile()</code> method takes a string (for instance, the contents of an uploaded raw C# file) and converts it into an in-memory assembly with the same assembly references as the main project.</p>

<p>The Roslyn compiler is still in beta, and the Microsoft team have recently removed some syntactic sugar which made the code in the <code>Compile()</code> routine look cleaner. Hopefully they will include something similar soon. The code below works with version 0.7.0.0.</p>

<p>```c#
public class PluginSnippetCompiler
{</p>

<pre><code>public PluginSnippetCompiler(IAssemblyReferenceCollector assemblyReferenceCollector)
{
    if (assemblyReferenceCollector == null)
        throw new ArgumentNullException("assemblyReferenceCollector");

    _AssemblyReferenceCollector = assemblyReferenceCollector;
}

private readonly IAssemblyReferenceCollector _AssemblyReferenceCollector;

private IEnumerable&lt;Diagnostic&gt; _Diagnostics = Enumerable.Empty&lt;Diagnostic&gt;();

public IEnumerable&lt;Diagnostic&gt; Errors
{
    get
    {
        return _Diagnostics
            .Where(d =&gt; d.Severity == DiagnosticSeverity.Error);
    }
}

public IEnumerable&lt;Diagnostic&gt; Warnings
{
    get
    {
        return _Diagnostics
            .Where(d =&gt; d.Severity == DiagnosticSeverity.Warning);
    }
}

private string GetOutputAssemblyName(string name)
{
    return String.Format("RoslynPlugins.Snippets.{0}", name);
}

/// &lt;summary&gt;
/// Compiles source code at runtime into an assembly. The assembly will automatically include all
/// the same assembly references as the main RoslynPlugins assembly, so you can call any function which is
/// available from within the deployed RoslynPlugins. Compilation errors and warnings can be obtained from 
/// the Errors and Warnings properties.
/// &lt;/summary&gt;
/// &lt;param name="name"&gt;The name of the class, e.g., HelloWorldGenerator&lt;/param&gt;
/// &lt;param name="script"&gt;Source code such as the contents of HelloWorldGenerator.cs&lt;/param&gt;
/// &lt;returns&gt;The compiled assembly in memory. If there were errors, it will return null.&lt;/returns&gt;
public Assembly Compile(string name, string script)
{
    if (name == null)
        throw new ArgumentNullException("name");

    if (script == null)
        throw new ArgumentNullException("script");

    string outputAssemblyName = GetOutputAssemblyName(name);

    var defaultImplementationAssembly = typeof(HelloWorldGenerator).Assembly;
    var assemblyReferences = _AssemblyReferenceCollector.CollectMetadataReferences(defaultImplementationAssembly);

    // Parse the script to a SyntaxTree
    var syntaxTree = CSharpSyntaxTree.ParseText(script);

    // Compile the SyntaxTree to an in memory assembly
    var compilation = CSharpCompilation.Create(outputAssemblyName,
        new[] { syntaxTree },
        assemblyReferences,
        new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

    using (var outputStream = new MemoryStream())
    {
        using (var pdbStream = new MemoryStream())
        {
            // Emit assembly to streams. Throw an exception if there are any compilation errors
            var result = compilation.Emit(outputStream, pdbStream: pdbStream);

            // Populate the _diagnostics property in order to read Errors and Warnings
            _Diagnostics = result.Diagnostics;

            if (result.Success)
            {
                return Assembly.Load(outputStream.ToArray(), pdbStream.ToArray());
            }
            else
            {
                return null;
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<p>In this demo, I have not included any user feedback about compilation errors, but they are easily obtainable from the <code>Errors</code> and <code>Warnings</code> properties. At present, if there is an error, the plug-in will be ignored and the original implementation will be used.</p>

<p>The class above depends on an <code>AssemblyReferenceCollector</code> which is responsible for enumerating the references to add to the runtime-generated plug-in assembly. We want exactly the same assembly references as the assembly which contains the original implementation so that we can reference any dependencies within those references.</p>

<p>```c#
public class AssemblyReferenceCollector : IAssemblyReferenceCollector
{</p>

<pre><code>public IEnumerable&lt;MetadataReference&gt; CollectMetadataReferences(Assembly assembly)
{
    var referencedAssemblyNames = assembly.GetReferencedAssemblies();

    var references = new List&lt;MetadataReference&gt;();
    foreach (AssemblyName assemblyName in referencedAssemblyNames)
    {
        var loadedAssembly = Assembly.Load(assemblyName);
        references
            .Add(new MetadataFileReference(loadedAssembly.Location));
    }

    references
        .Add(new MetadataFileReference(assembly.Location)); // add a reference to 'self', i.e., NetMWC

    return references;
}
</code></pre>

<p>}
```</p>

<h4>Connecting the pieces</h4>

<p>We need the <code>PluginLocator</code> class to connect the Ninject resolution root to the runtime-generated assembly (if one exists). It just looks for classes with the correct interface <code>IGenerator</code> within the <code>PluginAssemblyCache</code>.</p>

<p>Here's how it looks:</p>

<p>```c#
public class PluginLocator
{</p>

<pre><code>public PluginLocator(PluginAssemblyCache pluginAssemblyCache)
{
    if (pluginAssemblyCache == null)
        throw new ArgumentNullException("pluginAssemblyCache");

    _PluginAssemblyCache = pluginAssemblyCache;
}

private readonly PluginAssemblyCache _PluginAssemblyCache;

public Type Locate&lt;T&gt;()
{
    return Locate(new[] { typeof(T) });
}

protected Type Locate(IEnumerable&lt;Type&gt; serviceTypes)
{
    var implementingClasses = AssemblyExplorer.GetImplementingClasses(_PluginAssemblyCache.GetAssemblies(), serviceTypes);

    if (implementingClasses.Any())
    {
        if (implementingClasses.Count() &gt; 1)
            throw new Exception("More than one plugin class found which implements " + String.Join(" + ", serviceTypes.Select(t =&gt; t.ToString())));
        else
            return implementingClasses.Single();
    }
    return null;
}
</code></pre>

<p>}
```</p>

<p>The <code>PluginAssemblyCache</code> avoids having to run the <code>Compile()</code> routine more than once by maintaining a dictionary of previously compiled plug-ins. It has the following dependencies:</p>

<ul>
<li>an <code>IPluginSnippetProvider</code> which (in this case) reads the existing snippets from the database (not shown here)</li>
<li>a <code>PluginLoader</code> which uses the above <code>PluginSnippetCompiler</code> to convert a snippet into a runtime assembly.</li>
</ul>


<p>```c#</p>

<pre><code>/// &lt;summary&gt;
/// This class maintains a list of runtime-compiled in memory assemblies loaded from the plugins
/// available via the provider. It is a singleton class.
/// &lt;/summary&gt;
public class PluginAssemblyCache
{
    public PluginAssemblyCache(IPluginSnippetProvider pluginSnippetProvider, PluginLoader pluginLoader)
    {
        if (pluginSnippetProvider == null)
            throw new ArgumentNullException("pluginSnippetProvider");
        _PluginSnippetProvider = pluginSnippetProvider;

        if (pluginLoader == null)
            throw new ArgumentNullException("pluginLoader");
        _PluginLoader = pluginLoader;
    }

    private class CacheEntry
    {
        public string Name { get; set; }
        public Version Version { get; set; }
        public Assembly Assembly { get; set; }
    }

    private readonly IPluginSnippetProvider _PluginSnippetProvider;
    private readonly PluginLoader _PluginLoader;

    private List&lt;CacheEntry&gt; _Cache = new List&lt;CacheEntry&gt;();

    private void Add(string name, string version, Assembly assembly)
    {
        var cacheEntry =
            new CacheEntry()
            {
                Name = name,
                Version = new Version(version),
                Assembly = assembly
            };
        _Cache.Add(cacheEntry);
    }

    private void RefreshCache()
    {
        var pluginScriptContainers = _PluginSnippetProvider.GetPlugins();

        // Add a new assembly for any new or updated plugin
        foreach (var pluginScriptContainer in pluginScriptContainers)
        {
            var name = pluginScriptContainer.Name;
            var version = pluginScriptContainer.Version;
            if (!_Cache.Any(a =&gt; a.Name == name &amp;&amp; a.Version == new Version(version)))
            {
                var assembly = _PluginLoader.Load(pluginScriptContainer);
                Add(name, version, assembly);
            }
        }

        // Remove any assemblies which we no longer have a plugin for.
        _Cache
            .RemoveAll(cacheEntry =&gt;
                !pluginScriptContainers
                    .Select(plugin =&gt; plugin.Name)
                    .Contains(cacheEntry.Name));
    }

    public IEnumerable&lt;Assembly&gt; GetAssemblies()
    {
        RefreshCache();

        // Return only the assemblies with the highest version numbers
        return _Cache
            .GroupBy(d =&gt; d.Name)
            .Select(g =&gt; g
                    .OrderByDescending(d =&gt; d.Version)
                    .First()
                    .Assembly);
    }
}
</code></pre>

<p>```</p>

<p>So whenever the <code>SomeGenerator</code> class is resolved by Ninject, it will now</p>

<ul>
<li>Check whether there are any new plug-ins and compile them into runtime assemblies and add them to the <code>PluginAssemblyCache</code>.</li>
<li>Then the <code>PluginLocator</code> will search these assemblies for a newer version of <code>SomeGenerator</code>.</li>
<li>If it finds one, it will be resolved along with any constructor dependencies, otherwise it will use the original <code>SomeGenerator</code>.</li>
</ul>


<h4>Version numbers</h4>

<p>The version number of the plug-in is a key part of our solution. Let's say you have version 1.0 in production. Then you fix some bugs in staging (version 1.1). You create a plug-in from this staging code and upload it into production. Then much later, you decide to upgrade production to 1.2. Then, with the query in <code>GetAssemblies()</code>, the 1.1 plug-in will automatically be ignored and be superseded by whatever was shipped with 1.2 <em>since that is newer code</em>. So we do not have to remember to remove obsolete plug-ins after an upgrade - they will automatically be ignored because of the version number.</p>

<h4>Security</h4>

<p>Obviously, security is a chief concern and you may have to secure the plug-ins. In this demo project, I just created a simple view for the <code>IPlugin</code> object, but in our production environment we handle the creation of plug-ins differently. We use a combination of role-based security (to control who has permission to upload plugins) and encryption with checksumming. No user can directly enter arbitrary code - instead, we send the user a zip file which contains the code (encrypted), the version number and a checksum and our application verifies the checksum and builds the <code>IPlugin</code> object from the contents of the zip. A Powershell script running on our build server is responsible for creating the checksummed plug-in directly from the source code used in our staging environment.</p>

<h2>Conclusions - the ultimate plug-in framework?</h2>

<p>The strength of the Roslyn approach is that it is easy to maintain while being extremely versatile. In our case, it provides us with the ability to restrict the number of major releases approximately one per annum while catering for the inevitable little fixes to output formats and reports.</p>

<p>In the example we replaced an existing class, but it would be straightforward to add the concept of <em>discovery</em> and use the same Roslyn features to make any <em>new</em> plug-in classes available to your application. Ninject, makes it easy to instantiate, say, every implementor of <code>IGenerator</code>, so you could enumerate all available plug-ins instead of replacing a single one.</p>

<p>So here's a basic plug-in framework which is very flexible and very powerful without many of the versioning headaches of MEF or MAF. It's also easy to maintain, since the plug-in code is identical to the 'normal' code in staging (just packaged, delivered and compiled in a different way to production).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Replacing a class at runtime using Ninject and Roslyn - Part 3: Dependency Injection]]></title>
    <link href="http://ZeroSharp.github.com/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-3/"/>
    <updated>2014-09-15T08:01:00+01:00</updated>
    <id>http://ZeroSharp.github.com/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-3</id>
    <content type="html"><![CDATA[<p>This is the third part of a series about using Roslyn with dependency injection to create a flexible and powerful plug-in framework. Here I review the parts of the solution that deal with dependency injection. Check out <a href="https://github.com/ZeroSharp/RoslynPlugins">the working example on GitHub</a>.</p>

<p>Previously</p>

<ul>
<li><a href="/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-1/">Part 1: The Goal</a></li>
<li><a href="/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-2/">Part 2: The Solution</a></li>
</ul>


<h2>Dependency injection</h2>

<p>The first trick is to use dependency injection to create any instance of the <code>HelloWorldGenerator</code> class. Then if we need to add a new dependency to the class, we can just add it to the constructor without breaking anything.</p>

<p>```c# HelloWorldGenerator.cs
public class HelloWorldGenerator : IGenerator
{</p>

<pre><code>public HelloWorldGenerator(
    ISomeDependency dependency, 
    IAnotherDependency another, 
    INewDependency new // a new dependency!!!)
{
    ...
}
</code></pre>

<p>```</p>

<p>We'll use Ninject here, but you ought to be able to achieve the same with any dependency injection framework.</p>

<p>So normally, we'd have a binding something like:</p>

<p><code>c#
Bind&lt;IGenerator&gt;().To&lt;HelloWorldGenerator&gt;();
</code></p>

<p>Instead we'll replace this with a binding to a factory method instead.</p>

<p><code>c#
Bind&lt;IGenerator&gt;().ToMethod(context =&gt; CreatePluginInstance(context));
</code></p>

<p>The <code>CreatePluginInstance(context)</code> method will try to find an <code>IGenerator</code> class within any available plug-ins. If it finds one, it will ask the Ninject framework to create an instance of the plug-in class. Otherwise it falls back to the default type (the original implementation of the generator). The <code>PluginLocator</code> it is responsible for searching any runtime-compiled assemblies for candidate plug-ins. We'll look at it in more detail later.</p>

<p>```c#
private IGenerator CreatePluginInstance(IContext context)
{</p>

<pre><code>var pluginLocator = context.Kernel.Get&lt;PluginLocator&gt;();
Type roslynPluginType = pluginLocator.Locate&lt;IGenerator&gt;();

/// if we found a plug-in, create an instance of it
if (roslynPluginType != null)
    return (IGenerator)context.Kernel.Get(roslynPluginType);
else ///otherwise create an instance of the original implementation
    return context.Kernel.Get&lt;HelloWorldGenerator&gt;();
</code></pre>

<p>}
```</p>

<h4>By convention</h4>

<p>Of course, you might have dozens of <code>IGenerator</code> descendants, in which case you can use <a href="https://github.com/ninject/ninject.extensions.conventions">Ninject's convention-based binding module</a>. (Don't forget to add it with NuGet). My version looks something like the following.</p>

<p>```c#
/// If you have a lot of IGenerator subclasses, you can use Ninject's
/// convention based module.
///
///   For each Generator, bind to IGenerator.
///   For example, Bind<IGenerator>.To<SomeGenerator>();
///
Kernel.Bind(scanner => scanner</p>

<pre><code>.FromThisAssembly()
.SelectAllClasses()
.InheritedFrom(typeof(IGenerator))
.BindToPluginOtherwiseDefaultInterfaces()); //This is a custom extension method (see below)
</code></pre>

<p>```</p>

<p>```c#</p>

<pre><code>public static class ConventionSyntaxExtensions
{
    public static IConfigureSyntax BindToPluginOtherwiseDefaultInterfaces(this IJoinFilterWhereExcludeIncludeBindSyntax syntax)
    {
        return syntax.BindWith(new DefaultInterfacesBindingGenerator(new BindableTypeSelector(), new PluginOtherwiseDefaultBindingCreator()));
    }
}

/// &lt;summary&gt;
/// Returns a Ninject binding to a method which returns the plug-in type if one exists, otherwise returns the default type.
/// &lt;/summary&gt;
public class PluginOtherwiseDefaultBindingCreator : IBindingCreator
{
    public IEnumerable&lt;IBindingWhenInNamedWithOrOnSyntax&lt;object&gt;&gt; CreateBindings(IBindingRoot bindingRoot, IEnumerable&lt;Type&gt; serviceTypes, Type implementationType)
    {
        if (bindingRoot == null)
        {
            throw new ArgumentNullException("bindingRoot");
        }

        return !serviceTypes.Any()
         ? Enumerable.Empty&lt;IBindingWhenInNamedWithOrOnSyntax&lt;object&gt;&gt;()
         : new[] { bindingRoot.Bind(serviceTypes.ToArray()).ToMethod(context =&gt; context.Kernel.Get(context.Kernel.Get&lt;PluginLocator&gt;().Locate(serviceTypes) ?? implementationType)) };
    }
}
</code></pre>

<p>```</p>

<p>Next we'll look at <a href="/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-4/">the Roslyn part</a> in more detail.</p>
]]></content>
  </entry>
  
</feed>
