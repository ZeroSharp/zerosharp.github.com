<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: roslyn | ZeroSharp]]></title>
  <link href="http://ZeroSharp.github.com/blog/categories/roslyn/atom.xml" rel="self"/>
  <link href="http://ZeroSharp.github.com/"/>
  <updated>2014-09-15T09:45:35+01:00</updated>
  <id>http://ZeroSharp.github.com/</id>
  <author>
    <name><![CDATA[Robert Anderson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Replacing a class at runtime using Ninject and Roslyn - Part 3: Dependency Injection]]></title>
    <link href="http://ZeroSharp.github.com/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-3/"/>
    <updated>2014-09-15T08:01:00+01:00</updated>
    <id>http://ZeroSharp.github.com/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-3</id>
    <content type="html"><![CDATA[<p>Previously</p>

<ul>
<li><a href="/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-1/">Part 1: The Goal</a></li>
<li><a href="/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-2/">Part 2: The Solution</a></li>
</ul>


<h2>Dependency injection</h2>

<p>The first trick is to use dependency injection to create any instance of the <code>HelloWorldGenerator</code> class. Then if we need to add a new dependency to the class, we can just add it to the constructor without breaking anything.</p>

<p>```c# HelloWorldGenerator.cs
public class HelloWorldGenerator : IGenerator
{</p>

<pre><code>public HelloWorldGenerator(
    ISomeDependency dependency, 
    IAnotherDependency another, 
    INewDependency new // a new dependency!!!)
{
    ...
}
</code></pre>

<p>```</p>

<p>We'll use Ninject here, but you ought to be able to achieve the same with any dependency injection framework.</p>

<p>So normally, we'd have a binding something like:</p>

<p><code>c#
Bind&lt;IGenerator&gt;().To&lt;HelloWorldGenerator&gt;();
</code></p>

<p>Instead we'll replace this with a binding to a factory method instead.</p>

<p><code>c#
Bind&lt;IGenerator&gt;().ToMethod(context =&gt; CreatePluginInstance(context));
</code></p>

<p>The <code>CreatePluginInstance(context)</code> method will try to find an <code>IGenerator</code> class within any available plug-ins. If it finds one, it will ask the Ninject framework to create an instance of the plug-in class. Otherwise it falls back to the default type (the original implementation of the generator). The <code>PluginLocator</code> it is responsible for searching any runtime-compiled assemblies for candidate plug-ins. We'll look at it in more detail later.</p>

<p>```c#
private IGenerator CreatePluginInstance(IContext context)
{</p>

<pre><code>var pluginLocator = context.Kernel.Get&lt;PluginLocator&gt;();
Type roslynPluginType = pluginLocator.Locate&lt;IGenerator&gt;();

/// if we found a plug-in, create an instance of it
if (roslynPluginType != null)
    return (IGenerator)context.Kernel.Get(roslynPluginType);
else ///otherwise create an instance of the original implementation
    return context.Kernel.Get&lt;HelloWorldGenerator&gt;();
</code></pre>

<p>}
```</p>

<h4>By convention</h4>

<p>Of course, you might have dozens of <code>IGenerator</code> descendants, in which case you can use <a href="https://github.com/ninject/ninject.extensions.conventions">Ninject's convention-based binding module</a>. (Don't forget to add it with NuGet). My version looks something like the following.</p>

<p>```c#
/// If you have a lot of IGenerator subclasses, you can use Ninject's
/// convention based module.
///
///   For each Generator, bind to IGenerator.
///   For example, Bind<IGenerator>.To<SomeGenerator>();
///
Kernel.Bind(scanner => scanner</p>

<pre><code>.FromThisAssembly()
.SelectAllClasses()
.InheritedFrom(typeof(IGenerator))
.BindToPluginOtherwiseDefaultInterfaces()); //This is a custom extension method (see below)
</code></pre>

<p>```</p>

<p>```c#</p>

<pre><code>public static class ConventionSyntaxExtensions
{
    public static IConfigureSyntax BindToPluginOtherwiseDefaultInterfaces(this IJoinFilterWhereExcludeIncludeBindSyntax syntax)
    {
        return syntax.BindWith(new DefaultInterfacesBindingGenerator(new BindableTypeSelector(), new PluginOtherwiseDefaultBindingCreator()));
    }
}

/// &lt;summary&gt;
/// Returns a Ninject binding to a method which returns the plug-in type if one exists, otherwise returns the default type.
/// &lt;/summary&gt;
public class PluginOtherwiseDefaultBindingCreator : IBindingCreator
{
    public IEnumerable&lt;IBindingWhenInNamedWithOrOnSyntax&lt;object&gt;&gt; CreateBindings(IBindingRoot bindingRoot, IEnumerable&lt;Type&gt; serviceTypes, Type implementationType)
    {
        if (bindingRoot == null)
        {
            throw new ArgumentNullException("bindingRoot");
        }

        return !serviceTypes.Any()
         ? Enumerable.Empty&lt;IBindingWhenInNamedWithOrOnSyntax&lt;object&gt;&gt;()
         : new[] { bindingRoot.Bind(serviceTypes.ToArray()).ToMethod(context =&gt; context.Kernel.Get(context.Kernel.Get&lt;PluginLocator&gt;().Locate(serviceTypes) ?? implementationType)) };
    }
}
</code></pre>

<p>```</p>

<p>Next we'll look at the Roslyn part in more detail.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Replacing a class at runtime using Ninject and Roslyn - Part 2: The Solution]]></title>
    <link href="http://ZeroSharp.github.com/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-2/"/>
    <updated>2014-09-11T09:18:00+01:00</updated>
    <id>http://ZeroSharp.github.com/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-2</id>
    <content type="html"><![CDATA[<p>Previously: <a href="/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-1/">Part 1: The Goal</a></p>

<h2>The solution</h2>

<p>The code for the example is <a href="https://github.com/ZeroSharp/RoslynPlugins">available on GitHub</a>.</p>

<h4>How it looks</h4>

<p>So here's the Hello World page in production:</p>

<p><img src="/images/blog/roslyn-plugins-001.png">.</p>

<p>We navigate to the plugins view and create a new replacement for the HelloWorldGenerator:</p>

<p><img src="/images/blog/roslyn-plugins-002.png">.</p>

<p>Without restarting, we can return to the HelloWorld page and see that the new class is being used because the output has changed.</p>

<p><img src="/images/blog/roslyn-plugins-003.png">.</p>

<p>If you delete the row from the plugins page, the behaviour reverts to the original implementation (the code that was originally shipped with production).</p>

<h4>Basic project setup</h4>

<p>First, I created a new ASP.NET MVC 5 application. I added a HelloWorldContrroller and a View. I added a <code>Plugin</code> model and corresponding views. To get started I followed the tutorial here (http://www.asp.net/mvc/tutorials/mvc-5/introduction/getting-started). Once I had the basics in place, I added the following NuGet packages.</p>

<p><strong>Stable</strong></p>

<ul>
<li>EntityFramework</li>
<li>Ninject</li>
<li>Ninject.MVC5</li>
<li>Ninject.Conventions</li>
</ul>


<p><strong>Pre-release</strong></p>

<ul>
<li>Microsoft.CodeAnalysis.CSharp</li>
</ul>


<p>The <em>Microsoft.CodeAnalysis.CSharp</em> is the 'Roslyn' package. It is still in beta, so you have to switch to the pre-release.</p>

<p>Next we'll look at the dependency injection part in more detail.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Replacing a class at runtime using Ninject and Roslyn - Part 1: The Goal]]></title>
    <link href="http://ZeroSharp.github.com/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-1/"/>
    <updated>2014-09-09T10:47:00+01:00</updated>
    <id>http://ZeroSharp.github.com/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-1</id>
    <content type="html"><![CDATA[<h2>The goal</h2>

<p><span class='pullquote-right' data-pullquote='How can we replace a given class&#8217;s code with new code at runtime?'>
How can we replace a given class's code with new code at runtime? In particular, how we can we do this while allowing dependency injection and  sidestepping assembly versioning issues.
</span></p>

<p>Let's say you have bunch of classes like this:</p>

<p>```c# SomeGenerator.cs
public class SomeGenerator : IGenerator
{</p>

<pre><code>public SomeGenerator(ISomeDependency dependency, IAnotherDependency another)
{
    ...
}

public void Generate()
{
    ...
    // generate some output
}
</code></pre>

<p>}
```</p>

<p>Now let's assume that you need the ability to modify the behaviour of these classes at runtime without upgrading. And change the dependencies. Without restarting the application.</p>

<h4>Old school - The MEF approach (and most other plug-in frameworks)</h4>

<p>One approach would be to place each generator in a separate assembly and then you could load them at runtime. (This was my first effort - <em>oh how I struggled</em>).</p>

<p>You can make use of something like <a href="http://msdn.microsoft.com/en-us/library/dd460648.aspx">MEF</a> to help with the grunt work, but can still be very complex.</p>

<p>One difficulty is the dependencies. The dependencies are often defined in other assemblies and you have to be very careful to avoid 'dll hell'. It is very easy to get message like:</p>

<pre><code>Could not load file or assembly 'SomeAssembly, Version=1.2.9.1, Culture=neutral, PublicKeyToken=ad2d246d2bace800' or one of its dependencies. The located assembly's manifest definition does not match the assembly reference.
</code></pre>

<p>Or even exceptions like</p>

<pre><code>Object (of type 'SomeGenerator') is not of type 'SomeGenerator'.
</code></pre>

<p>You either have to write your plug-in code so that it is totally independent (i.e., has no dependencies), or you need to resort to a heap of <code>&lt;bindingRedirect&gt;</code> tags in your web.config.</p>

<p>Also, with one assembly per format, you can end up with a huge proliferation of assemblies. If you have 50 different formats, that would be 50 assemblies.</p>

<h4>New school - The Rosyln approach</h4>

<p>An alternative is to use the compiler-as-a-service features of <a href="http://msdn.microsoft.com/en-gb/vstudio/roslyn.aspx">Roslyn</a>.</p>

<p>Can we upload a modified <em>SomeGenerator.cs</em> and get it to reference the deployed assemblies and thereby avoid dll hell? With Roslyn we can do this.</p>

<p>If the compilation fails, we can immediately inform the user that the file is not compatible. If it succeeds, we can use it in lieu of the version that was originally deployed.</p>

<p>Also, you do <strong>not</strong> need separate assemblies for the plug-ins. Your production code contains, within it somewhere a class named <code>SomeGenerator</code>. At runtime, we are going to create an in-memory assembly which contains only a single class (still named <code>SomeGenerator</code>), but which can nevertheless reference any other class available to the original implementation. Then we will get the dependency injection container to 'replace' the old generator with the new one.</p>

<h2>The plan</h2>

<ul>
<li>Build an ASP.NET MVC 5 web application. It will use an instance of <code>HelloWorldGenerator</code> to generate some output. (This is the <em>original implementation</em>).</li>
<li>Allow a replacement for the <code>HelloWorldGenerator</code> class to be uploaded into the application as raw C# code. (This is the <em>plug-in implementation</em>.)</li>
<li>Store the C# code in a database. If the application is restarted, the plug-in code will be reloaded.</li>
<li>When the output is next requested, compile the new C# class. Any dependencies will be instantiated by the IoC container. If there are any compilation errors, these will be displayed.</li>
<li>Show that the plug-in class is now being used and the output has changed. The originally shipped <code>HelloWorldGenerator</code> class has been replaced by our plug-in.</li>
<li>Delete the plug-in from the table and show the output has reverted to the default (the originally implementation code).</li>
</ul>


<p>Over next few posts I'll guide you through building the application and demonstrate the runtime replacement of the generator class.</p>

<p>See <a href="/replacing-a-class-at-runtime-using-ninject-and-roslyn-part-2/">Part 2</a> for screen shots of the working application and an overview of the basic project set up.</p>
]]></content>
  </entry>
  
</feed>
