<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: nunit | ZeroSharp]]></title>
  <link href="http://ZeroSharp.github.com/blog/categories/nunit/atom.xml" rel="self"/>
  <link href="http://ZeroSharp.github.com/"/>
  <updated>2018-09-18T11:57:38+01:00</updated>
  <id>http://ZeroSharp.github.com/</id>
  <author>
    <name><![CDATA[Robert Anderson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sometimes you've just got to deploy]]></title>
    <link href="http://ZeroSharp.github.com/sometimes-youve-just-got-to-deploy/"/>
    <updated>2016-10-16T18:44:00+01:00</updated>
    <id>http://ZeroSharp.github.com/sometimes-youve-just-got-to-deploy</id>
    <content type="html"><![CDATA[<p>Sometimes the deadline has arrived and you still have some failing tests. After a discussion with the dev team, you decide to deploy anyway and fix the bugs for the next release. You need to get the build server to ignore the tests.</p>

<p>One way is just to mark the test with the <code>[Ignore]</code> attribute.</p>

<p>```c#
[Test]
[Ignore] // TODO: Fix this test before the next release!
public void Test()
{</p>

<pre><code>// Some failing test code...
</code></pre>

<p>}
```</p>

<p>After the weekend, everyone forgets about the ignored tests and they never get fixed.</p>

<p>Instead, I like to do this.
```c#
[Test]
public void Test()
{</p>

<pre><code>if (DateTime.Now &lt; new DateTime(2016, 10, 17))
    Assert.Ignore("Temporarily ignored until October 17.");
// Some failing test code...
</code></pre>

<p>}
```</p>

<p>This is a fairly rare occurrence for my team, so the above approach is sufficient and works with all test frameworks. But if you want to go further <a href="https://www.amido.com/code/conditional-ignore-nunit-and-the-ability-to-conditionally-ignore-a-test/">Richard Slater shows how to create an NUnit attribute</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing the property signatures of DevExpress validation rules using NUnit and LINQ]]></title>
    <link href="http://ZeroSharp.github.com/testing-the-property-signatures-of-devexpress-validation-rules-using-nunit-and-linq/"/>
    <updated>2012-05-24T16:39:00+01:00</updated>
    <id>http://ZeroSharp.github.com/testing-the-property-signatures-of-devexpress-validation-rules-using-nunit-and-linq</id>
    <content type="html"><![CDATA[<p>One of the projects I work on uses the validation module of the <a href="http://devexpress.com/Products/NET/Application_Framework/">eXpressApp Framework (XAF)</a>.  Since the business logic is complex, there are many validation rules defined using the <code>[RuleFromBoolProperty]</code>.</p>

<p>One of the recurring problems occurs when the signature of the associated property is incorrect.  Consider the following:</p>

<p>{% codeblock lang:csharp %}
[RuleFromBoolProperty("Invoice_IsAmountGreaterThanZero",
  DefaultContexts.Save,
  "Invoice amount must be greater than zero.",
  UsedProperties = "Amount")]
public bool IsAmountGreaterThanZero
{</p>

<pre><code>get
{
    return Amount &gt; 0;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Notice that the rule is declared <code>public</code>.  This causes the getter to be executed when it is not required (see the <a href="http://documentation.devexpress.com/#Xaf/clsDevExpressPersistentValidationRuleFromBoolPropertyAttributetopic">note</a> in the documentation).  However another problem is that the default behaviour for public properties of XPObjects is to persist them to the datastore which means the application will attempt to create a new column called <code>IsAmountGreaterThanZero</code>.</p>

<p>Instead, either property should be declared <code>protected</code> or the property should also have the <code>[NonPersistent]</code> and <code>[MemberDesignTimeVisibility(false)]</code> attributes as well.</p>

<p>Consequently, I wrote the following unit test which will detect any properties which have the <code>[RuleFromBoolProperty]</code> attribute.  This is not really a unit test, rather a sort of meta-test</p>

<p>{% codeblock lang:csharp %}
[TestFixture]
public class ValidationRuleDeclarationMetaTests
{</p>

<pre><code>[Test]
public void Test_RuleFromBoolPropertyDeclarations_ShouldBeProtectedVisibility()
{
    var assemblies = new Assembly[] { typeof(MyObjectAssembly).Assembly };

    var invalidProperties = assemblies.SelectMany(a =&gt; a.GetTypes())
                                      .SelectMany(t =&gt; t.GetProperties(BindingFlags.Public | BindingFlags.Instance))
                                      .Where(p =&gt; p.GetCustomAttributes(typeof(RuleFromBoolPropertyAttribute), true)
                                                   .Any())
                                      .Select(p =&gt; String.Format("{0}.{1}", p.DeclaringType, p.Name))
                                      .Distinct();

    Assert.IsFalse(invalidProperties.Any(), 
                   "There are 'public' properties with the [RuleFromBoolProperty] attribute. " + 
                   "These should be 'protected' instead. " + 
                   "The invalid properties are: " + String.Join(", ", invalidProperties));
}
</code></pre>

<p>} <br/>
{% endcodeblock %}</p>

<p>Now the build will fail whenever a validation property signature is incorrect.</p>
]]></content>
  </entry>
  
</feed>
